
ê(à((window.webpackJsonp=window.webpackJsonp||[]).push([[57],{581:function(e,t,r){"use strict";r.r(t);var a=r(24),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"merkle-directed-acyclic-graphs-dags"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#merkle-directed-acyclic-graphs-dags"}},[e._v("#")]),e._v(" Merkle Directed Acyclic Graphs (DAGs)")]),e._v(" "),r("div",{staticClass:"custom-block callout"},[r("p",[e._v("Take a deep dive into this superpowered, content-addresed data structure in ProtoSchool's tutorial, "),r("a",{attrs:{href:"https://proto.school/merkle-dags",target:"_blank",rel:"noopener noreferrer"}},[e._v("Merkle DAGs: Structuring Data for the Distributed Web"),r("OutboundLink")],1),e._v(".")])]),e._v(" "),r("p",[e._v("A Merkle DAG is a DAG where each node has an identifier, and this is the result of hashing the node's contents ‚Äî any opaque payload carried by the node and the list of identifiers of its children ‚Äî using a cryptographic hash function like SHA256. This brings some important considerations:")]),e._v(" "),r("ul",[r("li",[e._v("Merkle DAGs can only be constructed from the leaves, that is, from nodes without children. Parents are added after children because the children's identifiers must be computed in advance to be able to link them.")]),e._v(" "),r("li",[e._v("Every node in a Merkle DAG is the root of a (sub)Merkle DAG itself, and this subgraph is "),r("em",[e._v("contained")]),e._v(" in the parent DAG.")]),e._v(" "),r("li",[e._v("Merkle DAG nodes are "),r("em",[e._v("immutable")]),e._v(". Any change in a node would alter its identifier and thus affect all the ascendants in the DAG, essentially creating a different DAG. Take a look at "),r("a",{attrs:{href:"https://media.consensys.net/ever-wonder-how-merkle-trees-work-c2f8b7100ed3",target:"_blank",rel:"noopener noreferrer"}},[e._v("this helpful illustration using bananas"),r("OutboundLink")],1),e._v(" from our friends at Consensys.")])]),e._v(" "),r("p",[e._v("Merkle DAGs are similar to Merkle trees, but there are no balance requirements, and every node can carry a payload. In DAGs, several branches can re-converge or, in other words, a node can have several parents.")]),e._v(" "),r("p",[e._v("Identifying a data object (like a Merkle DAG node) by the value of its hash is referred to as "),r("em",[e._v("content addressing")]),e._v(". Thus, we name the node identifier as "),r("RouterLink",{attrs:{to:"/concepts/content-addressing/"}},[r("em",[e._v("Content Identifier")])]),e._v(", or CID.")],1),e._v(" "),r("p",[e._v("For example, the previous linked list, assuming that the payload of each node is just the CID of its descendant, would be: "),r("em",[e._v("A=Hash(B)‚ÜíB=Hash(C)‚ÜíC=Hash(‚àÖ)")]),e._v(". The properties of the hash function ensure that no cycles can exist when creating Merkle DAGs. (Note: Hash functions are one-way functions. Creating a cycle should then be impossibly difficult unless some weakness is discovered and exploited.)")]),e._v(" "),r("p",[e._v("Merkle DAGs are "),r("em",[e._v("self-verified")]),e._v(" structures. The CID of a node is univocally linked to the contents of its payload and those of all its descendants. Thus two nodes with the same CID univocally represent exactly the same DAG. This will be a key property to efficiently sync Merkle-CRDTs (Conflict-free Replicated Data Types) without having to copy the full DAG, as exploited by systems like IPFS. Merkle DAGs are very widely used. Source control systems like git and others use them to efficiently store the repository history in a way that enables de-duplicating the objects and detecting conflicts between branches.")]),e._v(" "),r("p",[e._v("Want to see a real-world example of Merkle DAGs in action? It's easy to see a Merkle DAG representation of a file of your choice using the "),r("a",{attrs:{href:"https://dag.ipfs.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("DAG Builder visualizer"),r("OutboundLink")],1),e._v(".")]),e._v(" "),r("h2",{attrs:{id:"further-resources"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#further-resources"}},[e._v("#")]),e._v(" Further resources")]),e._v(" "),r("ul",[r("li",[e._v("Full "),r("a",{attrs:{href:"https://hector.link/presentations/merkle-crdts/merkle-crdts.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("draft Merkle-CRDTs paper"),r("OutboundLink")],1),e._v(" by "),r("a",{attrs:{href:"https://www.github.com/hsanjuan",target:"_blank",rel:"noopener noreferrer"}},[e._v("@hsanjuan"),r("OutboundLink")],1),e._v(", "),r("a",{attrs:{href:"https://www.github.com/haadcode",target:"_blank",rel:"noopener noreferrer"}},[e._v("@haadcode"),r("OutboundLink")],1),e._v(", and "),r("a",{attrs:{href:"https://www.github.com/pgte",target:"_blank",rel:"noopener noreferrer"}},[e._v("@pgte"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://dag.ipfs.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("DAG Builder visualizer"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=n.exports}}]);à(