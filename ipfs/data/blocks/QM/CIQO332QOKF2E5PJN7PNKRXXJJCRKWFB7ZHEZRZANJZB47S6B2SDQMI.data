
³²©²(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{567:function(e,t,a){"use strict";a.r(t);var r=a(24),o=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"distributed-hash-tables-dhts"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#distributed-hash-tables-dhts"}},[e._v("#")]),e._v(" Distributed Hash Tables (DHTs)")]),e._v(" "),a("p",[e._v("A distributed hash table (DHT) is a distributed system for mapping keys to values. In IPFS, the DHT is used as the fundamental component of the content routing system and acts like a cross between a catalog and a navigation system. It maps what the user is looking for to the peer that is storing the matching content. Think of it as a huge table that stores "),a("em",[e._v("who")]),e._v(" has "),a("em",[e._v("what")]),e._v(" data. There are three types of key-value pairings that are mapped using the DHT:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Type")]),e._v(" "),a("th",[e._v("Purpose")]),e._v(" "),a("th",[e._v("Used by")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("Provider records")]),e._v(" "),a("td",[e._v("Map a data identifier (i.e., a multihash) to a peer that has advertised that they have that content and are willing to provide it to you.")]),e._v(" "),a("td",[e._v("- IPFS to find content"),a("br"),e._v(" - IPNS over PubSub to find other members of the pubsub "),a("em",[e._v("topic")]),e._v(".")])]),e._v(" "),a("tr",[a("td",[e._v("IPNS records")]),e._v(" "),a("td",[e._v("Map an IPNS key (i.e., the hash of a public key) to an IPNS record (i.e., a signed and versioned pointer to a path like "),a("code",[e._v("/ipfs/bafyxyz...")]),e._v(")")]),e._v(" "),a("td",[e._v("- IPNS")])]),e._v(" "),a("tr",[a("td",[e._v("Peer records")]),e._v(" "),a("td",[e._v("Map a peerID to a set of multiaddresses at which the peer may be reached")]),e._v(" "),a("td",[e._v("- IPFS when we know of a peer with content, but do not know its address."),a("br"),e._v(" - Manual connections (e.g., "),a("code",[e._v("ipfs swarm connect /p2p/Qmxyz...")]),e._v(")")])])])]),e._v(" "),a("p",[e._v("These record types hold slightly different semantics, but they are all updated and found using the same DHT protocol; IPFS's take on Kademlia.")]),e._v(" "),a("h2",{attrs:{id:"kademlia"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kademlia"}},[e._v("#")]),e._v(" Kademlia")]),e._v(" "),a("p",[e._v("The Kademlia algorithm has been around for a while, and it's purpose is to build a DHT on top of three system parameters:")]),e._v(" "),a("ol",[a("li",[e._v("An "),a("em",[e._v("address space")]),e._v(" as a way that all of the network peers can be uniquely identified. In IPFS, this is all the numbers from "),a("code",[e._v("0")]),e._v(" to "),a("code",[e._v("2^256-1")]),e._v(".")]),e._v(" "),a("li",[e._v("A "),a("em",[e._v("metric")]),e._v(" to order the peers in the address space and therefore visualize all the peers along a line ordered from smallest to largest. IPFS takes "),a("code",[e._v("SHA256(PeerID)")]),e._v(" and interprets it as an integer between "),a("code",[e._v("0")]),e._v(" and "),a("code",[e._v("2^256-1")]),e._v(".")]),e._v(" "),a("li",[e._v("A "),a("em",[e._v("projection")]),e._v(" that will take a "),a("code",[e._v("record key")]),e._v(" and calculate a position in the address space where the peer or peers most ideally suited to store the record should be near. IPFS uses "),a("code",[e._v("SHA256(Record Key)")]),e._v(".")])]),e._v(" "),a("p",[e._v("Having this address space and a peer ordering metric allows us to search the network as though it was a sorted list. In particular, we can turn the system into something like a "),a("em",[e._v("skip-list")]),e._v(" where a peer knows other peers with distances of around "),a("code",[e._v("1,2,4,8...")]),e._v(" away from it. This will allow us to search the list in time that is logarithmic in the network's size, "),a("code",[e._v("O(log(N))")]),e._v(" lookup time.")]),e._v(" "),a("p",[e._v("Unlike a skip-list, Kademlia is somewhat unstable since peers can join, leave, and rejoin the network at any time. To deal with the unstable nature of the system, a Kademlia peer does not just keep links to the peers with distance "),a("code",[e._v("1,2,4,8...")]),e._v(" away from it. Instead, for each multiple of 2 away, it keeps up to "),a("code",[e._v("K")]),e._v(" links. In IPFS "),a("code",[e._v("K = 20")]),e._v(". For example, instead of a peer keeping a single link 128 away, it would keep 20 links that are between 65 and 128 away.")]),e._v(" "),a("p",[e._v("The selection of network-wide parameters like "),a("code",[e._v("K")]),e._v(" is not arbitrary. It is determined based on the observed average "),a("em",[e._v("churn")]),e._v(" in the network and the frequency with which the network will republish information. System parameters, like "),a("code",[e._v("K")]),e._v(", are computed to maximize the probability that the network stays connected and that no data is lost while maintaining the desired latency for queries and assuming the average churn observations stay constant. These system and network parameters drive the decisions made in Kademlia's two main components: the routing table, which tracks all those links in the network, and the lookup algorithm, which determines how to traverse those links to store and retrieve data.")]),e._v(" "),a("h3",{attrs:{id:"undialable-peers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#undialable-peers"}},[e._v("#")]),e._v(" Undialable peers")]),e._v(" "),a("p",[e._v("A major property of Kademlia is that all peers can be arranged from smallest to largest. This is useful because as peer "),a("code",[e._v("0")]),e._v(" "),a("em",[e._v("walks")]),e._v(" down the line to find peer "),a("code",[e._v("55")]),e._v(", it can know it's getting progressively closer. However, this requires that everyone on the line can talk to each other. Otherwise, peer "),a("code",[e._v("33")]),e._v("might send peer"),a("code",[e._v("0")]),e._v(" down a dead-end by telling them the content they want is on a node they can't communicate with. This can result in a slow and fragmented network, with data being accessible by some peers and not others.")]),e._v(" "),a("p",[e._v("While having peers that cannot talk to each other may sound like an oddity, two prevalent causes of unreachability are network address translators (NATs) and firewalls. Having asymmetrical networks where peers "),a("code",[e._v("X")]),e._v(", "),a("code",[e._v("Y")]),e._v(", and "),a("code",[e._v("Z")]),e._v(" can connect to "),a("code",[e._v("A")]),e._v(", but "),a("code",[e._v("A")]),e._v(" cannot connect to them is fairly common. Similarly, it is "),a("em",[e._v("extremely")]),e._v(" common that peers "),a("code",[e._v("A")]),e._v(" and "),a("code",[e._v("B")]),e._v(", which are both behind NATs, cannot talk to each other. To deal with this, IPFS nodes ignore other nodes assumed to be unreachable by the general public. Nodes also filter themselves out of the network if they suspect they are not reachable.")]),e._v(" "),a("p",[e._v("To do this, we use "),a("a",{attrs:{href:"https://github.com/libp2p/go-libp2p-autonat",target:"_blank",rel:"noopener noreferrer"}},[e._v("libp2p's AutoNAT"),a("OutboundLink")],1),e._v(", which acts as a distributed "),a("em",[e._v("session traversal utility for NAT")]),e._v(" (STUN) layer, informing peers of their observed addresses and whether or not they appear to be publicly dialable. Only when peers detect that they are publicly dialable do they switch from client mode (where they can query the DHT but not respond to queries) to server mode (where they can both query and respond to queries). Similarly, if a server discovers that it is no longer publicly dialable, it will switch back into client mode.")]),e._v(" "),a("p",[e._v("IPFS exposes a "),a("em",[e._v("rate-limited")]),e._v(" AutoNAT service on all IPFS nodes that have discovered that they are publicly dialable. These requests are infrequent and do not have a noticeable overhead.")]),e._v(" "),a("h2",{attrs:{id:"dual-dht"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dual-dht"}},[e._v("#")]),e._v(" Dual DHT")]),e._v(" "),a("p",[e._v("Many IPFS nodes utilize the publicly shared DHT to discover and advertise content. However, some nodes operate in segregated networks such as local networks or isolated VPNs. For these users, having a DHT where all non-publicly dialable nodes are clients is very problematic since none of them are publicly dialable.")]),e._v(" "),a("p",[e._v("A separate DHT is available to nodes that are not part of the public network called "),a("em",[e._v("LAN DHT")]),e._v(". This is completely separate from the public "),a("em",[e._v("WAN DHT")]),e._v(". These two DHTs are separated by utilizing different DHT protocol names:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("DHT")]),e._v(" "),a("th",[e._v("Path")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("WAN")]),e._v(" "),a("td",[a("code",[e._v("/ipfs/kad/1.0.0")])])]),e._v(" "),a("tr",[a("td",[e._v("LAN")]),e._v(" "),a("td",[a("code",[e._v("/ipfs/lan/kad/1.0.0")])])])])]),e._v(" "),a("p",[e._v("The main difference between the WAN and LAN DHTs are the acceptance criteria for peers: which peers are eligible to be part of a routing table or query and which are not. The WAN DHT's criteria is "),a("em",[e._v("do you look like a public address")]),e._v(", and the LAN DHT's criteria is "),a("em",[e._v("do you look like a non-public address")]),e._v(". While WAN DHT nodes switch from client to server mode based on whether they are publicly dialable, LAN DHT nodes are always servers unless the "),a("code",[e._v("dhtclient")]),e._v(" option has been set.")]),e._v(" "),a("h2",{attrs:{id:"routing-tables"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#routing-tables"}},[e._v("#")]),e._v(" Routing Tables")]),e._v(" "),a("p",[e._v("A routing table is a set of rules used to decide where data traveling over a network should go. All IP-enabled devices, including routers and switches, use routing tables. Every IPFS peer maintains a routing table with links to other peers in the network. IPFS relies on Kademlia to define what should and should not go into the routing table:")]),e._v(" "),a("ol",[a("li",[e._v("When we connect to a peer, check if it qualifies to be added to our routing table.")]),e._v(" "),a("li",[e._v("If it qualifies, determine how close the new peer is to us to figure out which "),a("em",[e._v("bucket")]),e._v(" it should go into.")]),e._v(" "),a("li",[e._v("Attempt to put the peer in the bucket.")]),e._v(" "),a("li",[e._v("If we ever fail to connect to a peer in our routing table, drop them from the routing table.")])]),e._v(" "),a("p",[e._v("There are three properties of note here: "),a("a",{attrs:{href:"#qualification"}},[e._v("qualification")]),e._v(", "),a("a",{attrs:{href:"#peer-buckets"}},[e._v("buckets")]),e._v(", and "),a("a",{attrs:{href:"#refreshing-and-dropping-peers"}},[e._v("refreshing/dropping peers")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"qualification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#qualification"}},[e._v("#")]),e._v(" Qualification")]),e._v(" "),a("p",[e._v("Qualifying peers that can be added into a routing table fit these two criteria:")]),e._v(" "),a("ol",[a("li",[e._v("Ensure the peer is a DHT server that is advertising the DHT protocol ID, "),a("code",[e._v("/ipfs/kad/1.0.0")]),e._v(" for the WAN DHT, and "),a("code",[e._v("/ipfs/lan/kad/1.0.0")]),e._v(" for the LAN DHT.")]),e._v(" "),a("li",[e._v("Ensure the peer has IP addresses that match the ranges we expect. For example, members of the public DHT having at least one public range IP address as opposed to only addresses like "),a("code",[e._v("192.168.X.Y")])])]),e._v(" "),a("h3",{attrs:{id:"peer-buckets"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#peer-buckets"}},[e._v("#")]),e._v(" Peer buckets")]),e._v(" "),a("p",[e._v("A bucket is a collection of up to 20 peers that have "),a("em",[e._v("similar")]),e._v(" addresses. For example, if the peer is between "),a("code",[e._v("2^7")]),e._v(" and "),a("code",[e._v("2^8")]),e._v(" away from us, and the address space is of size "),a("code",[e._v("2^256")]),e._v(", the peer goes into bucket "),a("code",[e._v("256-8")]),e._v(". Peers can be added into a bucket if that bucket has less than 20 peers. If the bucket already has 20 peers, then IPFS determines if any peers can be "),a("a",{attrs:{href:"#refreshing-and-dropping-peers"}},[e._v("dropped")]),e._v(". Otherwise, IPFS doesn't add the peer to the bucket.")]),e._v(" "),a("h3",{attrs:{id:"refreshing-and-dropping-peers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#refreshing-and-dropping-peers"}},[e._v("#")]),e._v(" Refreshing and dropping peers")]),e._v(" "),a("p",[e._v("To keep the routing tables accurate and up to date, IPFS refreshes the routing table every 10 minutes. While this is likely a higher frequency than is strictly necessary, it's important to protect the network's health as IPFS learns more about the dynamics of the DHT network. A routing table refresh works as follows:")]),e._v(" "),a("ol",[a("li",[e._v("Go through all the buckets, from bucket "),a("code",[e._v("0")]),e._v(" up until the highest bucket we have that contains a peer in it. The highest possible bucket number is capped at 15.\n"),a("ol",[a("li",[e._v("For each bucket, select a random address in the Kademlia space that could fit in that bucket and do a lookup to find the "),a("code",[e._v("K")]),e._v(" closest peers to that random address. This will ensure that we will have filled up each bucket with as many peers as will fit.")])])]),e._v(" "),a("li",[e._v("Also, search for ourselves in the network, just in case the network size and distribution are such that the first 15 buckets do not suffice to learn about the "),a("code",[e._v("K")]),e._v(" peers closest to us.")])]),e._v(" "),a("p",[e._v("Peers can be dropped from the routing table for several reasons, usually because that peer is offline or unreachable. After every refresh, IPFS goes through the routing table and attempt to connect to peers that we have not queried recently. If any peers are not active or online, they are dropped from the routing table. Peers can also be dropped if they have not been useful within the time period during which they are "),a("em",[e._v("probabilistically expected")]),e._v(" to have been utilized in a refresh. That value is "),a("code",[e._v("Log(1/K) * Log(1 - Î±/K) * refreshPeriod")]),e._v(", where "),a("code",[e._v("Î±")]),e._v(" is the number of peers dialed that can be simultaneously queried. Additionally, IPFS defines "),a("em",[e._v("useful")]),e._v(" as responding within 2x when it takes any other peer from our routing table to respond to us. This biases against peers that are slow, overloaded, unreliable, or have bad network connectivity to us.")]),e._v(" "),a("h2",{attrs:{id:"lookup-algorithm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lookup-algorithm"}},[e._v("#")]),e._v(" Lookup algorithm")]),e._v(" "),a("p",[e._v("The lookup algorithm answers the question "),a("em",[e._v("What are the "),a("code",[e._v("K")]),e._v(" closest peers to "),a("code",[e._v("X")]),e._v("?")]),e._v(". The IPFS implementation of the Kademlia lookup algorithm uses the following workflow:")]),e._v(" "),a("ol",[a("li",[e._v("Load the "),a("code",[e._v("K")]),e._v(" closest peers to "),a("code",[e._v("X")]),e._v(" from our routing table into the query-queue.")]),e._v(" "),a("li",[e._v("Allowing up to 10 concurrent queries, grab the peer closest to "),a("code",[e._v("X")]),e._v(" and ask them "),a("em",[e._v("who are the "),a("code",[e._v("K")]),e._v(" closest peers to "),a("code",[e._v("X")]),e._v("?")])]),e._v(" "),a("li",[e._v("When a query to a peer finishes, add those results to the query-queue.")]),e._v(" "),a("li",[e._v("Pull the next-closest peer off the queue and query them.")]),e._v(" "),a("li",[e._v("The query terminates whenever the closest known three peers to "),a("code",[e._v("X")]),e._v(" have been successfully queried without any timeouts or errors.")]),e._v(" "),a("li",[e._v("After the query is done, take the "),a("code",[e._v("K")]),e._v(" closest peers that have not failed and return them.")])]),e._v(" "),a("h2",{attrs:{id:"routing-particulars"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#routing-particulars"}},[e._v("#")]),e._v(" Routing particulars")]),e._v(" "),a("p",[e._v("While the lookup algorithm is what allows IPFS to "),a("code",[e._v("PUT")]),e._v(" and "),a("code",[e._v("GET")]),e._v(" records into the DHT, how this is done is slightly different for each record type:")]),e._v(" "),a("h3",{attrs:{id:"provider-records"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#provider-records"}},[e._v("#")]),e._v(" Provider records")]),e._v(" "),a("p",[e._v("For a block with Multihash "),a("code",[e._v("H")]),e._v(":")]),e._v(" "),a("h4",{attrs:{id:"provide-put"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#provide-put"}},[e._v("#")]),e._v(" Provide "),a("code",[e._v("PUT")])]),e._v(" "),a("ol",[a("li",[e._v("Do a standard lookup for the "),a("code",[e._v("K")]),e._v(" closest peers to "),a("code",[e._v("SHA256(H)")])]),e._v(" "),a("li",[e._v("Put the provider record at those K closest peers, and also store it ourselves.")]),e._v(" "),a("li",[e._v("Currently, you are only allowed to put a provider record for yourself. "),a("em",[e._v("Alice")]),e._v(" cannot advertise that "),a("em",[e._v("Bob")]),e._v(" has content.")])]),e._v(" "),a("h4",{attrs:{id:"provider-get"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#provider-get"}},[e._v("#")]),e._v(" Provider "),a("code",[e._v("GET")])]),e._v(" "),a("ol",[a("li",[e._v("Do a lookup for the "),a("code",[e._v("K")]),e._v(" closest peers to "),a("code",[e._v("X=SHA256(H)")]),e._v(".")]),e._v(" "),a("li",[e._v("Ask each peer "),a("em",[e._v("who are the "),a("code",[e._v("K")]),e._v(" closest peers to "),a("code",[e._v("X")]),e._v(" you know about?")]),e._v(".")]),e._v(" "),a("li",[e._v("Also, ask "),a("em",[e._v("send me the record corresponding to "),a("code",[e._v("X")]),e._v(" if you have it")]),e._v(".")])]),e._v(" "),a("p",[e._v("The peer adds new providers it has learned about and continues until the lookup terminates. Depending on which API is used, the lookup can also be forced to abort after receiving a certain number of provider records.")]),e._v(" "),a("h3",{attrs:{id:"ipns-records"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ipns-records"}},[e._v("#")]),e._v(" IPNS Records")]),e._v(" "),a("p",[e._v("For an IPNS key where the multihash of the public key is "),a("code",[e._v("H")]),e._v(":")]),e._v(" "),a("h4",{attrs:{id:"ipns-put"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ipns-put"}},[e._v("#")]),e._v(" IPNS "),a("code",[e._v("PUT")])]),e._v(" "),a("ol",[a("li",[e._v("Do a standard lookup for the "),a("code",[e._v("K")]),e._v(" closest peers to "),a("code",[e._v("SHA256(/ipns/H)")]),e._v(".")]),e._v(" "),a("li",[e._v("Put the IPNS record at those "),a("code",[e._v("K")]),e._v(" closest peers and store it ourselves.")])]),e._v(" "),a("h4",{attrs:{id:"ipns-get"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ipns-get"}},[e._v("#")]),e._v(" IPNS "),a("code",[e._v("GET")])]),e._v(" "),a("ol",[a("li",[a("p",[e._v("Do a lookup for the "),a("code",[e._v("K")]),e._v(" closest peers to "),a("code",[e._v("X=SHA256(/ipns/H)")]),e._v(".")])]),e._v(" "),a("li",[a("p",[e._v("Ask each peer "),a("em",[e._v("who are the "),a("code",[e._v("K")]),e._v(" closest peers to "),a("code",[e._v("X")]),e._v(" you know about?")])])]),e._v(" "),a("li",[a("p",[e._v("Also, ask "),a("em",[e._v("send me the record corresponding to "),a("code",[e._v("X")]),e._v(" if you have it")]),e._v(".")])]),e._v(" "),a("li",[a("p",[e._v("If we receive a record with a higher IPNS sequence number, update the existing one, and continue until the lookup terminates.")]),e._v(" "),a("p",[e._v("This is needed to make sure that the user gets the latest record. Recall that IPNS records are mutable, and therefore, we need to make sure that we point a request to the latest version of the content.")])]),e._v(" "),a("li",[a("p",[e._v("Once the lookup is done, if any of the "),a("code",[e._v("K")]),e._v(" closest peers to "),a("code",[e._v("X")]),e._v(" did not have the newest IPNS record, send them the newest record.")])])]),e._v(" "),a("h3",{attrs:{id:"peer-records"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#peer-records"}},[e._v("#")]),e._v(" Peer records")]),e._v(" "),a("p",[e._v("For a peer where the multihash of the public key is "),a("code",[e._v("H")]),e._v(":")]),e._v(" "),a("h4",{attrs:{id:"peer-records-put"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#peer-records-put"}},[e._v("#")]),e._v(" Peer records "),a("code",[e._v("PUT")])]),e._v(" "),a("p",[e._v("When libp2p peers connect, they exchange peer information automatically. Being part of the DHT as either a client or server requires frequent contact with your "),a("code",[e._v("K")]),e._v(" closest peers; therefore, they inherently end up with your peer record.")]),e._v(" "),a("h4",{attrs:{id:"peer-records-get"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#peer-records-get"}},[e._v("#")]),e._v(" Peer records "),a("code",[e._v("GET")])]),e._v(" "),a("ol",[a("li",[e._v("Do a lookup for the "),a("code",[e._v("K")]),e._v(" closest peers to "),a("code",[e._v("X=SHA256(H)")]),e._v(".")]),e._v(" "),a("li",[e._v("Ask each peer "),a("em",[e._v("who are the "),a("code",[e._v("K")]),e._v(" closest peers to "),a("code",[e._v("X")]),e._v(" you know about?")])]),e._v(" "),a("li",[e._v("Also, ask "),a("em",[e._v("send me the peer record for "),a("code",[e._v("H")]),e._v(" if you have it")]),e._v(".")])]),e._v(" "),a("p",[e._v("IPFS tries to connect to the peer with ID "),a("code",[e._v("H")]),e._v(" as soon as we learn addresses about it. The lookup can terminate early if we end up connecting to the peer.")]),e._v(" "),a("h2",{attrs:{id:"learn-more"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#learn-more"}},[e._v("#")]),e._v(" Learn more")]),e._v(" "),a("p",[e._v("If you're eager for more information about the DHT, take a look at these resources:")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://blog.ipfs.io/2020-07-20-dht-deep-dive/",target:"_blank",rel:"noopener noreferrer"}},[a("em",[e._v("Content Routing Improvements: Deep Dive")]),e._v(" blog post"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://www.youtube.com/watch?v=G8FvB_0HlCE",target:"_blank",rel:"noopener noreferrer"}},[e._v("Go-IPFS 0.5.0 release highlights"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=o.exports}}]);©²